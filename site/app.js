const byId = (id) => document.getElementById(id);
const SUBSCRIBE_URL_BASE = "https://github.com/pingfanfan/AK-RSS/issues/new";
const LANG_KEY = "akrss_lang";
const SITE_HOME_URL = "https://pingfanfan.github.io/AK-RSS/";

const I18N = {
  en: {
    page_title: "AK Signal Desk",
    tag: "AK-RSS • Andrej K Extended Signal Desk",
    hero_title: "AK Signal Desk",
    subtitle: "Your OPML-powered engineering radar: fresh blog updates, AI brief analysis, and copy-ready daily posts.",
    refresh: "Refresh Now",
    open_opml: "Open Feed List (OPML)",
    lang_zh: "中文",
    lang_en: "English",
    value_pill_1: "2h email alerts",
    value_pill_2: "AI TLDR + Why + Action",
    value_pill_3: "X / LinkedIn / Threads ready",
    curation_title: "Feed DNA",
    curation_text:
      "Seeded from your OPML and expanded with Andrej K-style recommendations to keep signal high across engineering, AI, security, and infra.",
    subscribe_title: "2-Hour Email Subscription",
    subscribe_text: "Enter your email to receive new updates every 2 hours.",
    subscribe_placeholder: "you@example.com",
    subscribe_button: "Subscribe",
    subscribe_hint: "You will be redirected to a GitHub issue confirmation page.",
    subscribe_hint_opening: "Opening subscription confirmation page...",
    subscribe_hint_invalid: "Please enter a valid email address.",
    stats_updates: "Tracked Updates",
    stats_today: "Today",
    stats_feeds: "Active Feeds",
    stats_latest: "Latest Source",
    panel_daily: "Daily Social Summary",
    panel_live: "Live Update Stream",
    empty_updates: "No fresh updates yet. The next run will append new entries here.",
    empty_daily: "Daily summary will appear after enough updates are collected.",
    last_sync: "Last sync",
    no_sync: "No sync yet",
    load_failed: "Load failed",
    updates_unit: "updates",
    days_unit: "days",
    label_tldr: "TLDR",
    label_why: "Why it matters",
    label_action: "Action",
    translation_prefix: "Translation:",
    source_label: "Original",
    copy_x: "Copy X Post",
    copy_linkedin: "Copy LinkedIn Post",
    copy_threads: "Copy Threads Post",
    copy_selected: "Copy Selected",
    option_x: "X (+source)",
    option_linkedin: "LinkedIn (+source)",
    option_threads: "Threads (+source)",
    download_image: "Download Image",
    downloading_image: "Rendering...",
    downloaded: "Downloaded",
    download_failed: "Download failed",
    entry_image_title: "Live Signal Card",
    day_image_title: "Daily Signal Card",
    image_summary: "Summary",
    image_keypoints: "Key Points",
    image_sources: "Sources",
    image_footer: "Generated by AK Signal Desk",
    image_qr_hint: "Scan for live dashboard",
    copied: "Copied",
    copy_failed: "Copy failed",
    day_summary_label: "Daily Summary",
    preview_label: "Preview"
  },
  zh: {
    page_title: "AK 信号台",
    tag: "AK-RSS · Andrej K 补全信号台",
    hero_title: "AK 信号台",
    subtitle: "把博客更新变成可执行情报：实时抓新、AI 简析、可直接发布的社媒总结。",
    refresh: "立即刷新",
    open_opml: "查看信源清单（OPML）",
    lang_zh: "中文",
    lang_en: "English",
    value_pill_1: "每 2 小时邮件提醒",
    value_pill_2: "AI：TLDR + 价值 + 动作",
    value_pill_3: "X / LinkedIn / Threads 一键复制",
    curation_title: "信源 DNA",
    curation_text: "以你的 OPML 为种子，并加入 Andrej K 风格的补全推荐，聚焦工程、AI、安全与基础设施高信号内容。",
    subscribe_title: "每 2 小时邮件订阅",
    subscribe_text: "输入邮箱后，每 2 小时接收一次新增更新。",
    subscribe_placeholder: "you@example.com",
    subscribe_button: "订阅",
    subscribe_hint: "将跳转到 GitHub Issue 页面完成确认。",
    subscribe_hint_opening: "正在打开订阅确认页面...",
    subscribe_hint_invalid: "请输入有效邮箱地址。",
    stats_updates: "累计更新",
    stats_today: "今日条数",
    stats_feeds: "活跃信源",
    stats_latest: "最新来源",
    panel_daily: "每日社媒总结",
    panel_live: "滚动更新",
    empty_updates: "暂时没有新更新，下一轮任务会自动追加。",
    empty_daily: "积累足够更新后会自动生成每日摘要。",
    last_sync: "最近同步",
    no_sync: "暂无同步记录",
    load_failed: "加载失败",
    updates_unit: "条更新",
    days_unit: "天",
    label_tldr: "TLDR",
    label_why: "为什么重要",
    label_action: "建议动作",
    translation_prefix: "翻译：",
    source_label: "原文",
    copy_x: "复制 X 文案",
    copy_linkedin: "复制 LinkedIn 文案",
    copy_threads: "复制 Threads 文案",
    copy_selected: "复制选中内容",
    option_x: "X（含来源）",
    option_linkedin: "LinkedIn（含来源）",
    option_threads: "Threads（含来源）",
    download_image: "下载分享图",
    downloading_image: "生成中...",
    downloaded: "已下载",
    download_failed: "下载失败",
    entry_image_title: "实时信号卡",
    day_image_title: "每日信号卡",
    image_summary: "总结",
    image_keypoints: "要点",
    image_sources: "来源",
    image_footer: "由 AK 信号台自动生成",
    image_qr_hint: "扫码查看实时看板",
    copied: "已复制",
    copy_failed: "复制失败",
    day_summary_label: "当日总结",
    preview_label: "预览"
  }
};

function detectLang() {
  const saved = localStorage.getItem(LANG_KEY);
  if (saved === "zh" || saved === "en") return saved;
  return (navigator.language || "").toLowerCase().startsWith("zh") ? "zh" : "en";
}

let currentLang = detectLang();
let latestPayload = {
  updates: { updates: [], count: 0 },
  daily: { days: [] }
};

const formatters = {
  en: {
    full: new Intl.DateTimeFormat("en-GB", {
      year: "numeric",
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      timeZone: "Europe/London"
    }),
    short: new Intl.DateTimeFormat("en-GB", {
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      timeZone: "Europe/London"
    })
  },
  zh: {
    full: new Intl.DateTimeFormat("zh-CN", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      timeZone: "Europe/London"
    }),
    short: new Intl.DateTimeFormat("zh-CN", {
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      timeZone: "Europe/London"
    })
  }
};

function t(key) {
  return I18N[currentLang][key] || I18N.en[key] || key;
}

function pickLocalized(item, base) {
  if (!item) return "";
  if (currentLang === "zh") {
    return item[`${base}_zh`] || item[base] || item[`${base}_en`] || "";
  }
  return item[`${base}_en`] || item[base] || item[`${base}_zh`] || "";
}

function normalizeText(s) {
  return (s || "").trim().replace(/\s+/g, " ").toLowerCase();
}

function getTitleTranslation(item) {
  const original = (item.title || "").trim();
  const translated = currentLang === "zh" ? (item.title_zh || "") : (item.title_en || "");
  if (!translated) return "";
  if (normalizeText(original) === normalizeText(translated)) return "";
  return translated.trim();
}

function setupStaticText() {
  document.documentElement.lang = currentLang === "zh" ? "zh-CN" : "en";
  document.title = t("page_title");

  byId("tagText").textContent = t("tag");
  byId("heroTitle").textContent = t("hero_title");
  byId("subtitleText").textContent = t("subtitle");
  renderValuePills();
  byId("refreshBtn").textContent = t("refresh");
  byId("openOpmlLink").textContent = t("open_opml");

  byId("langBtnZh").textContent = t("lang_zh");
  byId("langBtnEn").textContent = t("lang_en");

  byId("curationTitle").textContent = t("curation_title");
  byId("curationText").textContent = t("curation_text");

  byId("subscribeTitle").textContent = t("subscribe_title");
  byId("subscribeText").textContent = t("subscribe_text");
  byId("subscribeEmail").placeholder = t("subscribe_placeholder");
  byId("subscribeSubmit").textContent = t("subscribe_button");

  const hint = byId("subscribeHint");
  if (!hint.dataset.userEdited) {
    hint.textContent = t("subscribe_hint");
  }

  byId("dailyHeading").textContent = t("panel_daily");
  byId("liveHeading").textContent = t("panel_live");

  byId("langBtnZh").classList.toggle("active", currentLang === "zh");
  byId("langBtnEn").classList.toggle("active", currentLang === "en");
}

function renderValuePills() {
  const root = byId("valuePills");
  if (!root) return;
  root.innerHTML = "";
  [t("value_pill_1"), t("value_pill_2"), t("value_pill_3")].forEach((label) => {
    const item = document.createElement("span");
    item.className = "value-pill";
    item.textContent = label;
    root.appendChild(item);
  });
}

function statNode(k, v) {
  const card = document.createElement("article");
  card.className = "stat";

  const key = document.createElement("p");
  key.className = "stat-k";
  key.textContent = k;

  const val = document.createElement("p");
  val.className = "stat-v";
  val.textContent = String(v);

  card.appendChild(key);
  card.appendChild(val);
  return card;
}

function renderStats(updates, daily) {
  const el = byId("stats");
  el.innerHTML = "";

  const days = daily.days || [];
  const items = updates.updates || [];
  const activeFeeds = new Set(items.map((x) => x.feed_title).filter(Boolean)).size;
  const today = days[0]?.total || 0;
  const top = items[0]?.feed_title || "-";

  [
    [t("stats_updates"), updates.count || 0],
    [t("stats_today"), today],
    [t("stats_feeds"), activeFeeds],
    [t("stats_latest"), top]
  ].forEach(([k, v]) => el.appendChild(statNode(k, v)));
}

function renderMarquee(updates) {
  const root = byId("feedMarquee");
  const feeds = Array.from(new Set((updates.updates || []).map((u) => u.feed_title).filter(Boolean))).slice(0, 24);
  if (feeds.length === 0) {
    root.innerHTML = `<div class="marquee-track"><span class="feed-chip">${t("empty_updates")}</span></div>`;
    return;
  }

  const row = [...feeds, ...feeds];
  const track = document.createElement("div");
  track.className = "marquee-track";
  row.forEach((feed) => {
    const chip = document.createElement("span");
    chip.className = "feed-chip";
    chip.textContent = feed;
    track.appendChild(chip);
  });

  root.innerHTML = "";
  root.appendChild(track);
}

async function copyWithFeedback(btn, content, defaultLabel) {
  try {
    await navigator.clipboard.writeText(content || "");
    btn.textContent = t("copied");
  } catch {
    btn.textContent = t("copy_failed");
  }
  setTimeout(() => {
    btn.textContent = defaultLabel;
  }, 1200);
}

function waitForFontsReady() {
  if (document.fonts && document.fonts.ready) {
    return document.fonts.ready.catch(() => {});
  }
  return Promise.resolve();
}

function roundedRectPath(ctx, x, y, w, h, r) {
  const rr = Math.max(0, Math.min(r, w / 2, h / 2));
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y, x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x, y + h, rr);
  ctx.arcTo(x, y + h, x, y, rr);
  ctx.arcTo(x, y, x + w, y, rr);
  ctx.closePath();
}

function fillRoundedRect(ctx, x, y, w, h, r, fill) {
  ctx.save();
  ctx.fillStyle = fill;
  roundedRectPath(ctx, x, y, w, h, r);
  ctx.fill();
  ctx.restore();
}

function strokeRoundedRect(ctx, x, y, w, h, r, color, lineWidth = 1) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  roundedRectPath(ctx, x, y, w, h, r);
  ctx.stroke();
  ctx.restore();
}

function wrapLines(ctx, text, maxWidth, maxLines = 0) {
  const lines = [];
  const rawLines = String(text || "").replace(/\r/g, "").split("\n");

  for (const rawLine of rawLines) {
    const source = rawLine.trim();
    if (!source) {
      if (lines.length === 0 || lines[lines.length - 1] !== "") {
        lines.push("");
      }
      continue;
    }

    let current = "";
    for (const char of source) {
      const test = current + char;
      if (ctx.measureText(test).width <= maxWidth || current.length === 0) {
        current = test;
      } else {
        lines.push(current.trimEnd());
        current = char;
      }
    }
    if (current) lines.push(current.trimEnd());
  }

  let result = lines.filter((line, idx) => line !== "" || idx === 0 || idx === lines.length - 1);
  if (result.length === 0) result = [""];

  if (maxLines > 0 && result.length > maxLines) {
    result = result.slice(0, maxLines);
    let last = result[maxLines - 1];
    while (last && ctx.measureText(`${last}…`).width > maxWidth) {
      last = last.slice(0, -1);
    }
    result[maxLines - 1] = `${last || ""}…`;
  }

  return result;
}

function drawTextBlock(ctx, options) {
  const {
    text,
    x,
    y,
    maxWidth,
    lineHeight,
    font,
    color,
    maxLines = 0
  } = options;

  ctx.save();
  ctx.font = font;
  ctx.fillStyle = color;
  ctx.textBaseline = "top";
  const lines = wrapLines(ctx, text, maxWidth, maxLines);
  lines.forEach((line, idx) => {
    ctx.fillText(line, x, y + idx * lineHeight);
  });
  ctx.restore();
  return y + lines.length * lineHeight;
}

function safeCardText(text) {
  return String(text || "").replace(/\s+/g, " ").trim();
}

function compactSource(link) {
  const input = (link || "").trim();
  if (!input) return "";
  try {
    const url = new URL(input);
    const path = (url.pathname || "").replace(/\/$/, "");
    const merged = `${url.hostname}${path && path !== "/" ? path : ""}`;
    if (merged.length > 76) return `${merged.slice(0, 75)}…`;
    return merged;
  } catch {
    return input.length > 76 ? `${input.slice(0, 75)}…` : input;
  }
}

function sanitizeFilename(text, fallback) {
  const slug = (text || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 36);
  return slug || fallback;
}

function buildCardFilename(prefix, title, fallback) {
  const datePart = new Date().toISOString().slice(0, 10);
  const slug = sanitizeFilename(title, fallback);
  return `${prefix}-${slug}-${datePart}.png`;
}

function paintCardShell(ctx, badge, stamp) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  const bg = ctx.createLinearGradient(0, 0, w, h);
  bg.addColorStop(0, "#f7f2e9");
  bg.addColorStop(0.55, "#edf3ff");
  bg.addColorStop(1, "#e8f8ef");
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, w, h);

  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#6c7dff";
  ctx.beginPath();
  ctx.arc(210, 220, 180, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#0f9b6b";
  ctx.beginPath();
  ctx.arc(w - 120, 280, 210, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#d8742f";
  ctx.beginPath();
  ctx.arc(w / 2, h - 110, 240, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  const pad = 56;
  const cardX = pad;
  const cardY = 64;
  const cardW = w - pad * 2;
  const cardH = h - pad - 86;

  ctx.save();
  ctx.shadowColor = "rgba(24, 33, 52, 0.16)";
  ctx.shadowBlur = 36;
  ctx.shadowOffsetY = 16;
  fillRoundedRect(ctx, cardX, cardY, cardW, cardH, 38, "rgba(255, 255, 255, 0.92)");
  ctx.restore();
  strokeRoundedRect(ctx, cardX, cardY, cardW, cardH, 38, "rgba(182, 190, 213, 0.7)", 1.5);

  const topBar = ctx.createLinearGradient(cardX, cardY, cardX + cardW, cardY);
  topBar.addColorStop(0, "rgba(31, 77, 198, 0.12)");
  topBar.addColorStop(1, "rgba(15, 122, 86, 0.12)");
  fillRoundedRect(ctx, cardX + 26, cardY + 24, cardW - 52, 86, 24, topBar);

  const badgeX = cardX + 46;
  const badgeY = cardY + 45;
  ctx.save();
  ctx.font = '700 20px "Sora", sans-serif';
  const badgeW = ctx.measureText(badge).width + 28;
  fillRoundedRect(ctx, badgeX, badgeY, badgeW, 34, 17, "rgba(39, 86, 206, 0.15)");
  strokeRoundedRect(ctx, badgeX, badgeY, badgeW, 34, 17, "rgba(39, 86, 206, 0.34)");
  ctx.fillStyle = "#20479f";
  ctx.textBaseline = "middle";
  ctx.fillText(badge, badgeX + 14, badgeY + 18);
  ctx.restore();

  ctx.save();
  ctx.fillStyle = "#2a395f";
  ctx.font = '600 16px "Sora", sans-serif';
  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  ctx.fillText(stamp || "", cardX + cardW - 44, badgeY + 18);
  ctx.restore();

  ctx.save();
  ctx.fillStyle = "#11203d";
  ctx.font = '700 52px "Fraunces", serif';
  ctx.textBaseline = "top";
  ctx.fillText(t("page_title"), cardX + 44, cardY + 118);
  ctx.restore();

  return {
    x: cardX + 46,
    y: cardY + 198,
    width: cardW - 92,
    footerY: cardY + cardH - 44
  };
}

function drawSectionBlock(ctx, label, text, x, y, width, maxLines = 3) {
  const content = safeCardText(text);
  if (!content) return y;

  ctx.save();
  ctx.font = '700 16px "Sora", sans-serif';
  const pillW = ctx.measureText(label).width + 22;
  fillRoundedRect(ctx, x, y, pillW, 28, 14, "rgba(45, 96, 221, 0.1)");
  strokeRoundedRect(ctx, x, y, pillW, 28, 14, "rgba(45, 96, 221, 0.22)");
  ctx.fillStyle = "#2d53b1";
  ctx.textBaseline = "middle";
  ctx.fillText(label, x + 11, y + 15);
  ctx.restore();

  const nextY = drawTextBlock(ctx, {
    text: content,
    x,
    y: y + 36,
    maxWidth: width,
    lineHeight: 33,
    maxLines,
    font: '500 24px "Sora", sans-serif',
    color: "#1f2e4a"
  });
  return nextY + 14;
}

function drawBulletList(ctx, points, x, y, width, maxItems = 4) {
  const rows = (points || []).filter(Boolean).map(safeCardText).filter(Boolean).slice(0, maxItems);
  if (rows.length === 0) return y;

  let cursor = y;
  rows.forEach((point) => {
    const endY = drawTextBlock(ctx, {
      text: `• ${point}`,
      x,
      y: cursor,
      maxWidth: width,
      lineHeight: 31,
      maxLines: 2,
      font: '500 23px "Sora", sans-serif',
      color: "#20314d"
    });
    cursor = endY + 8;
  });
  return cursor;
}

function buildQrModules(text) {
  if (typeof window.qrcode !== "function") return null;
  try {
    const qr = window.qrcode(0, "M");
    qr.addData(text);
    qr.make();
    const size = qr.getModuleCount();
    const grid = [];
    for (let r = 0; r < size; r += 1) {
      const row = [];
      for (let c = 0; c < size; c += 1) {
        row.push(qr.isDark(r, c));
      }
      grid.push(row);
    }
    return { size, grid };
  } catch {
    return null;
  }
}

function drawQrPanel(ctx, options) {
  const { x, y, url, hint } = options;
  const panelW = 248;
  const panelH = 274;
  const qrBox = 188;
  const qrPad = 12;
  const qrX = x + (panelW - qrBox) / 2;
  const qrY = y + 16;

  fillRoundedRect(ctx, x, y, panelW, panelH, 20, "rgba(247, 250, 255, 0.94)");
  strokeRoundedRect(ctx, x, y, panelW, panelH, 20, "rgba(166, 177, 211, 0.65)");
  fillRoundedRect(ctx, qrX, qrY, qrBox, qrBox, 16, "#ffffff");
  strokeRoundedRect(ctx, qrX, qrY, qrBox, qrBox, 16, "rgba(163, 178, 214, 0.5)");

  const modules = buildQrModules(url);
  if (modules) {
    const moduleCount = modules.size;
    const quiet = 4;
    const totalModules = moduleCount + quiet * 2;
    const dot = (qrBox - qrPad * 2) / totalModules;
    const originX = qrX + qrPad;
    const originY = qrY + qrPad;
    ctx.save();
    ctx.fillStyle = "#13274a";
    for (let r = 0; r < moduleCount; r += 1) {
      for (let c = 0; c < moduleCount; c += 1) {
        if (!modules.grid[r][c]) continue;
        const px = originX + (c + quiet) * dot;
        const py = originY + (r + quiet) * dot;
        ctx.fillRect(px, py, dot + 0.25, dot + 0.25);
      }
    }
    ctx.restore();
  } else {
    ctx.save();
    ctx.font = '600 16px "Sora", sans-serif';
    ctx.fillStyle = "#43527a";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("QR", qrX + qrBox / 2, qrY + qrBox / 2);
    ctx.restore();
  }

  ctx.save();
  ctx.fillStyle = "#2a3f6f";
  ctx.font = '700 15px "Sora", sans-serif';
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText(hint, x + panelW / 2, qrY + qrBox + 12);
  ctx.restore();
}

function buildEntryShareCanvas(item) {
  const canvas = document.createElement("canvas");
  canvas.width = 1080;
  canvas.height = 1350;
  const ctx = canvas.getContext("2d");

  const stamp = item.published ? formatters[currentLang].full.format(new Date(item.published)) : "";
  const frame = paintCardShell(ctx, t("entry_image_title"), stamp);

  const displayTitle = safeCardText(currentLang === "zh" ? (item.title_zh || item.title) : (item.title_en || item.title));
  let y = drawTextBlock(ctx, {
    text: displayTitle || item.title || "(untitled)",
    x: frame.x,
    y: frame.y,
    maxWidth: frame.width,
    lineHeight: 54,
    maxLines: 3,
    font: '700 44px "Fraunces", serif',
    color: "#101d36"
  }) + 10;

  const translation = safeCardText(getTitleTranslation(item));
  if (translation) {
    y = drawTextBlock(ctx, {
      text: `${t("translation_prefix")} ${translation}`,
      x: frame.x,
      y,
      maxWidth: frame.width,
      lineHeight: 30,
      maxLines: 2,
      font: '500 21px "Sora", sans-serif',
      color: "#5d6f98"
    }) + 10;
  }

  const tldr = pickLocalized(item, "tldr") || pickLocalized(item, "what");
  const why = pickLocalized(item, "why");
  const action = pickLocalized(item, "action");
  y = drawSectionBlock(ctx, t("label_tldr"), tldr, frame.x, y, frame.width, 3);
  y = drawSectionBlock(ctx, t("label_why"), why, frame.x, y, frame.width, 3);
  y = drawSectionBlock(ctx, t("label_action"), action, frame.x, y, frame.width, 2);

  const sourceText = compactSource(item.link);
  y = drawSectionBlock(ctx, t("image_sources"), sourceText, frame.x, y, frame.width - 272, 2);

  drawQrPanel(ctx, {
    x: frame.x + frame.width - 248,
    y: frame.footerY - 286,
    url: SITE_HOME_URL,
    hint: t("image_qr_hint")
  });

  ctx.save();
  ctx.fillStyle = "#445375";
  ctx.font = '600 16px "Sora", sans-serif';
  ctx.textBaseline = "bottom";
  const feedName = safeCardText(item.feed_title || "");
  const footer = feedName ? `${feedName} · ${t("image_footer")}` : t("image_footer");
  ctx.fillText(footer, frame.x, frame.footerY);
  ctx.restore();

  return canvas;
}

function buildDailyShareCanvas(day) {
  const canvas = document.createElement("canvas");
  canvas.width = 1080;
  canvas.height = 1350;
  const ctx = canvas.getContext("2d");
  const frame = paintCardShell(ctx, t("day_image_title"), day.date || "");

  let y = drawTextBlock(ctx, {
    text: `${day.date || ""} · ${day.total || 0} ${t("updates_unit")}`,
    x: frame.x,
    y: frame.y,
    maxWidth: frame.width,
    lineHeight: 46,
    maxLines: 2,
    font: '700 38px "Fraunces", serif',
    color: "#142240"
  }) + 8;

  const summary = currentLang === "zh"
    ? safeCardText(day.summary_zh || "")
    : safeCardText(day.summary_en || "");
  const summaryFallback = (currentLang === "zh"
    ? (day.key_points_zh || day.key_points || [])
    : (day.key_points_en || day.key_points || [])).slice(0, 3).join(currentLang === "zh" ? "；" : "; ");
  y = drawSectionBlock(ctx, t("image_summary"), summary || summaryFallback, frame.x, y, frame.width, 4);

  ctx.save();
  ctx.font = '700 16px "Sora", sans-serif';
  const pointPillW = ctx.measureText(t("image_keypoints")).width + 22;
  fillRoundedRect(ctx, frame.x, y, pointPillW, 28, 14, "rgba(15, 122, 86, 0.12)");
  strokeRoundedRect(ctx, frame.x, y, pointPillW, 28, 14, "rgba(15, 122, 86, 0.3)");
  ctx.fillStyle = "#0f6d4f";
  ctx.textBaseline = "middle";
  ctx.fillText(t("image_keypoints"), frame.x + 11, y + 15);
  ctx.restore();

  const points = currentLang === "zh"
    ? (day.key_points_zh || day.key_points || [])
    : (day.key_points_en || day.key_points || []);
  y = drawBulletList(ctx, points, frame.x, y + 36, frame.width, 4) + 4;

  const sources = (day.sources || []).map((s) => compactSource(s.link)).filter(Boolean).slice(0, 3);
  y = drawSectionBlock(ctx, t("image_sources"), sources.join("\n"), frame.x, y, frame.width - 272, 4);

  drawQrPanel(ctx, {
    x: frame.x + frame.width - 248,
    y: frame.footerY - 286,
    url: SITE_HOME_URL,
    hint: t("image_qr_hint")
  });

  ctx.save();
  ctx.fillStyle = "#445375";
  ctx.font = '600 16px "Sora", sans-serif';
  ctx.textBaseline = "bottom";
  const feedLine = (day.feeds || []).slice(0, 3).join(" · ");
  const footer = feedLine ? `${feedLine} · ${t("image_footer")}` : t("image_footer");
  ctx.fillText(footer, frame.x, frame.footerY);
  ctx.restore();

  return canvas;
}

function downloadCanvas(canvas, filename) {
  return new Promise((resolve, reject) => {
    const saveBlob = (blob) => {
      if (!blob) {
        reject(new Error("empty blob"));
        return;
      }
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      resolve();
    };

    if (canvas.toBlob) {
      canvas.toBlob(saveBlob, "image/png");
      return;
    }

    try {
      const fallbackUrl = canvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.href = fallbackUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      resolve();
    } catch (err) {
      reject(err);
    }
  });
}

async function downloadImageWithFeedback(btn, label, buildCanvas, filename) {
  btn.disabled = true;
  btn.textContent = t("downloading_image");
  try {
    await waitForFontsReady();
    const canvas = buildCanvas();
    await downloadCanvas(canvas, filename);
    btn.textContent = t("downloaded");
  } catch {
    btn.textContent = t("download_failed");
  }

  setTimeout(() => {
    btn.disabled = false;
    btn.textContent = label;
  }, 1400);
}

function hasExplicitSourceBlock(text) {
  return /(?:^|\n)\s*(?:sources?|来源)\s*[:：]/im.test(text || "");
}

function buildEntrySourceSuffix(item) {
  const link = (item?.link || "").trim();
  if (!link) return "";
  return currentLang === "zh" ? `\n来源: ${link}` : `\nSource: ${link}`;
}

function buildDaySourceSuffix(day, mode = "short") {
  const links = (day?.sources || [])
    .map((s) => (s?.link || "").trim())
    .filter(Boolean)
    .slice(0, 3);
  if (links.length === 0) return "";

  const limited = mode === "short" ? links.slice(0, 1) : links;
  const header = currentLang === "zh" ? "来源:" : "Sources:";
  if (mode === "short") {
    return currentLang === "zh" ? `\n来源: ${limited[0]}` : `\nSource: ${limited[0]}`;
  }
  return `\n\n${header}\n${limited.map((u) => `- ${u}`).join("\n")}`;
}

function withRequiredSource(text, sourceSuffix) {
  const base = (text || "").trim();
  const suffix = (sourceSuffix || "").trim();
  if (!suffix) return base;
  if (!base) return suffix;
  if (hasExplicitSourceBlock(base)) return base;
  return `${base}\n${suffix}`;
}

function shortPreview(text, max = 110) {
  const normalized = (text || "").replace(/\s+/g, " ").trim();
  if (normalized.length <= max) return normalized;
  return `${normalized.slice(0, max - 1)}…`;
}

function renderTimeline(updates) {
  const list = byId("timeline");
  const tmpl = byId("timelineItemTmpl");
  const items = updates.updates || [];
  list.innerHTML = "";

  if (items.length === 0) {
    const empty = document.createElement("p");
    empty.className = "empty";
    empty.textContent = t("empty_updates");
    list.appendChild(empty);
  }

  const shortFmt = formatters[currentLang].short;

  items.forEach((item) => {
    const node = tmpl.content.firstElementChild.cloneNode(true);
    node.querySelector(".entry-feed").textContent = item.feed_title || "Unknown feed";
    node.querySelector(".entry-time").textContent = item.published ? shortFmt.format(new Date(item.published)) : "";

    const a = node.querySelector(".entry-title");
    a.textContent = item.title || "(untitled)";
    a.href = item.link || "#";

    const translated = getTitleTranslation(item);
    const tNode = node.querySelector(".entry-title-translation");
    if (translated) {
      tNode.textContent = `${t("translation_prefix")} ${translated}`;
    } else {
      tNode.remove();
    }

    const tldr = pickLocalized(item, "tldr") || pickLocalized(item, "what");
    const why = pickLocalized(item, "why");
    const action = pickLocalized(item, "action");

    node.querySelector(".entry-tldr").textContent = `${t("label_tldr")}: ${tldr || ""}`;
    node.querySelector(".entry-why").textContent = `${t("label_why")}: ${why || ""}`;
    node.querySelector(".entry-action").textContent = `${t("label_action")}: ${action || ""}`;

    const postMap = {
      x: withRequiredSource(
        pickLocalized(item, "x") || pickLocalized(item, "tweet") || `${item.title || ""} ${item.link || ""}`.trim(),
        buildEntrySourceSuffix(item)
      ),
      linkedin: withRequiredSource(
        pickLocalized(item, "linkedin") || pickLocalized(item, "x") || pickLocalized(item, "tweet") || item.title || "",
        buildEntrySourceSuffix(item)
      ),
      threads: withRequiredSource(
        pickLocalized(item, "threads") || pickLocalized(item, "x") || pickLocalized(item, "tweet") || item.title || "",
        buildEntrySourceSuffix(item)
      )
    };

    const options = [
      { value: "x", label: t("option_x") },
      { value: "linkedin", label: t("option_linkedin") },
      { value: "threads", label: t("option_threads") }
    ];

    const select = node.querySelector(".entry-copy-kind");
    select.innerHTML = "";
    options.forEach((opt) => {
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.label;
      select.appendChild(o);
    });

    const preview = node.querySelector(".tweet-preview");
    const updatePreview = () => {
      preview.textContent = shortPreview(postMap[select.value] || "");
    };
    updatePreview();
    select.addEventListener("change", updatePreview);

    const btn = node.querySelector(".tweet-btn");
    const label = t("copy_selected");
    btn.textContent = label;
    btn.addEventListener("click", () => copyWithFeedback(btn, postMap[select.value] || "", label));

    const imageBtn = node.querySelector(".entry-image-btn");
    const imageLabel = t("download_image");
    imageBtn.textContent = imageLabel;
    imageBtn.addEventListener("click", () => {
      const filename = buildCardFilename("ak-update", item.title || item.feed_title || "", "update");
      return downloadImageWithFeedback(imageBtn, imageLabel, () => buildEntryShareCanvas(item), filename);
    });

    list.appendChild(node);
  });

  byId("updateCount").textContent = `${items.length} ${t("updates_unit")}`;
}

function dailyPlatformText(day, platform) {
  const postObj = day.social_posts?.[platform] || {};
  const localized = currentLang === "zh" ? (postObj.zh || postObj.en) : (postObj.en || postObj.zh);
  if (localized) return localized;

  const fallback = day.tweet_drafts || [];
  return fallback.slice(0, 2).join("\n") || "";
}

function buildBullets(points) {
  return (points || [])
    .slice(0, 4)
    .filter(Boolean)
    .map((point) => {
      const li = document.createElement("li");
      li.textContent = point;
      return li;
    });
}

function renderDaily(daily) {
  const list = byId("dailyList");
  const tmpl = byId("dailyItemTmpl");
  const days = daily.days || [];
  list.innerHTML = "";

  if (days.length === 0) {
    const empty = document.createElement("p");
    empty.className = "empty";
    empty.textContent = t("empty_daily");
    list.appendChild(empty);
  }

  days.forEach((d) => {
    const node = tmpl.content.firstElementChild.cloneNode(true);
    node.querySelector(".day-date").textContent = d.date;
    node.querySelector(".day-total").textContent = `${d.total} ${t("updates_unit")}`;
    node.querySelector(".day-feeds").textContent = (d.feeds || []).slice(0, 4).join(" · ");

    const localizedPoints = currentLang === "zh"
      ? (d.key_points_zh || d.key_points || [])
      : (d.key_points_en || d.key_points || []);
    const summary = currentLang === "zh" ? (d.summary_zh || "") : (d.summary_en || "");
    const summaryFallback = localizedPoints.slice(0, 3).join(currentLang === "zh" ? "；" : "; ");
    node.querySelector(".day-summary-label").textContent = t("day_summary_label");
    node.querySelector(".day-summary").textContent = summary || summaryFallback;

    const ul = node.querySelector(".day-points");
    buildBullets(localizedPoints).forEach((li) => ul.appendChild(li));

    const options = [
      { value: "x", label: t("option_x") },
      { value: "linkedin", label: t("option_linkedin") },
      { value: "threads", label: t("option_threads") }
    ];
    const select = node.querySelector(".day-copy-kind");
    select.innerHTML = "";
    options.forEach((opt) => {
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.label;
      select.appendChild(o);
    });

    const contentMap = {
      x: withRequiredSource(dailyPlatformText(d, "x"), buildDaySourceSuffix(d, "short")),
      linkedin: withRequiredSource(dailyPlatformText(d, "linkedin"), buildDaySourceSuffix(d, "full")),
      threads: withRequiredSource(dailyPlatformText(d, "threads"), buildDaySourceSuffix(d, "short"))
    };

    const previewNode = node.querySelector(".day-copy-preview");
    const updatePreview = () => {
      previewNode.textContent = shortPreview(contentMap[select.value] || "", 130);
    };
    updatePreview();
    select.addEventListener("change", updatePreview);

    const btn = node.querySelector(".day-copy-btn");
    const label = t("copy_selected");
    btn.textContent = label;
    btn.addEventListener("click", () => copyWithFeedback(btn, contentMap[select.value] || "", label));

    const imageBtn = node.querySelector(".day-image-btn");
    const imageLabel = t("download_image");
    imageBtn.textContent = imageLabel;
    imageBtn.addEventListener("click", () => {
      const filename = buildCardFilename("ak-daily", d.date || "", "daily");
      return downloadImageWithFeedback(imageBtn, imageLabel, () => buildDailyShareCanvas(d), filename);
    });

    list.appendChild(node);
  });

  byId("dayCount").textContent = `${days.length} ${t("days_unit")}`;
}

function renderLastUpdated(updates) {
  const fullFmt = formatters[currentLang].full;
  const el = byId("lastUpdated");
  if (updates.generated_at) {
    el.textContent = `${t("last_sync")}: ${fullFmt.format(new Date(updates.generated_at))}`;
    return;
  }
  el.textContent = t("no_sync");
}

function renderAll() {
  setupStaticText();
  const updates = latestPayload.updates || { updates: [], count: 0 };
  const daily = latestPayload.daily || { days: [] };

  renderStats(updates, daily);
  renderMarquee(updates);
  renderTimeline(updates);
  renderDaily(daily);
  renderLastUpdated(updates);
}

async function fetchJSON(path) {
  const res = await fetch(`${path}?t=${Date.now()}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`${path} ${res.status}`);
  return res.json();
}

async function load() {
  try {
    const [updates, daily] = await Promise.all([fetchJSON("./data/updates.json"), fetchJSON("./data/daily.json")]);
    latestPayload = { updates, daily };
    renderAll();
  } catch (err) {
    byId("lastUpdated").textContent = `${t("load_failed")}: ${err.message}`;
  }
}

function setLang(next) {
  if (next !== "zh" && next !== "en") return;
  currentLang = next;
  localStorage.setItem(LANG_KEY, next);
  renderAll();
}

function validEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function wireSubscribeForm() {
  const form = byId("subscribeForm");
  const emailInput = byId("subscribeEmail");
  const hint = byId("subscribeHint");
  if (!form || !emailInput || !hint) return;

  form.addEventListener("submit", (e) => {
    e.preventDefault();
    const email = (emailInput.value || "").trim().toLowerCase();
    if (!validEmail(email)) {
      hint.textContent = t("subscribe_hint_invalid");
      hint.dataset.userEdited = "1";
      return;
    }

    const title = `[subscribe] ${email}`;
    const body = [
      `EMAIL: ${email}`,
      "",
      "SOURCE: github-pages",
      "",
      "Keep this issue OPEN to stay subscribed.",
      "Close this issue to unsubscribe."
    ].join("\n");

    const url = `${SUBSCRIBE_URL_BASE}?title=${encodeURIComponent(title)}&body=${encodeURIComponent(body)}`;
    hint.textContent = t("subscribe_hint_opening");
    hint.dataset.userEdited = "1";
    window.open(url, "_blank", "noopener");
  });
}

function wireEvents() {
  byId("refreshBtn").addEventListener("click", load);
  byId("langBtnZh").addEventListener("click", () => setLang("zh"));
  byId("langBtnEn").addEventListener("click", () => setLang("en"));
  wireSubscribeForm();
}

wireEvents();
renderAll();
setInterval(load, 60000);
load();
